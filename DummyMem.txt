685
Created new folder: ./data3_/res/_685
set seed: 5
Making ./raw_data/dblp.txt graph...
Done ./raw_data/dblp.txt Peter...
Graph with 9916 nodes and 44808 edges
Size of subgraph: 9872
Reading subgraph at ./data3_/dblp/10/0/subgraph.txt
Reading alignment at ./data3_/dblp/10/0/nodes.txt
Making ./data3_/dblp/10/0/subgraph.txt graph...
Done ./data3_/dblp/10/0/subgraph.txt Peter...
Graph with 9872 nodes and 39561 edges
Alpine_Dummy
Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    96   2108.2 MiB   2108.2 MiB           1   @profile
    97                                         def feature_extraction1(G,simple = True):
    98                                             """Node feature extraction.
    99                                         
   100                                             Parameters
   101                                             ----------
   102                                         
   103                                             G (nx.Graph): a networkx graph.
   104                                         
   105                                             Returns
   106                                             -------
   107                                         
   108                                             node_features (float): the Nx7 matrix of node features."""
   109                                             #G = standardize_nodes(G)
   110                                             # necessary data structures
   111   2108.2 MiB      0.0 MiB           1       node_features = np.zeros(shape=(G.number_of_nodes(), 2))
   112   2108.2 MiB      0.0 MiB           1       node_list = sorted(G.nodes())
   113   2108.2 MiB      0.0 MiB           1       node_degree_dict = dict(G.degree())
   114                                         
   115                                             # node degrees
   116   2108.2 MiB      0.0 MiB        9919       degs = [node_degree_dict[n] for n in node_list]
   117   2108.2 MiB      0.0 MiB           1       node_features[:, 0] = degs
   118   2108.2 MiB      0.0 MiB           1       node_features = np.nan_to_num(node_features)
   119   2249.7 MiB    141.5 MiB        9919       egonets = {n: nx.ego_graph(G, n) for n in node_list}
   120   2250.6 MiB      0.0 MiB        9920       neighbor_degs = [
   121   2250.6 MiB      0.9 MiB      118786           np.mean([node_degree_dict[m] for m in egonets[n].nodes if m != n])
   122   2250.6 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   123                                                 else 0
   124   2250.6 MiB      0.0 MiB        9917           for n in node_list
   125                                             ]
   126   2250.6 MiB      0.0 MiB           1       node_features[:, 1] = neighbor_degs
   127   2250.7 MiB      0.2 MiB           1       return np.nan_to_num(node_features)


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    96   2124.5 MiB   2124.5 MiB           1   @profile
    97                                         def feature_extraction1(G,simple = True):
    98                                             """Node feature extraction.
    99                                         
   100                                             Parameters
   101                                             ----------
   102                                         
   103                                             G (nx.Graph): a networkx graph.
   104                                         
   105                                             Returns
   106                                             -------
   107                                         
   108                                             node_features (float): the Nx7 matrix of node features."""
   109                                             #G = standardize_nodes(G)
   110                                             # necessary data structures
   111   2124.5 MiB      0.0 MiB           1       node_features = np.zeros(shape=(G.number_of_nodes(), 2))
   112   2124.5 MiB      0.0 MiB           1       node_list = sorted(G.nodes())
   113   2124.5 MiB      0.0 MiB           1       node_degree_dict = dict(G.degree())
   114                                         
   115                                             # node degrees
   116   2124.5 MiB      0.0 MiB        9919       degs = [node_degree_dict[n] for n in node_list]
   117   2124.5 MiB      0.0 MiB           1       node_features[:, 0] = degs
   118   2124.5 MiB      0.0 MiB           1       node_features = np.nan_to_num(node_features)
   119   2272.3 MiB    147.8 MiB        9919       egonets = {n: nx.ego_graph(G, n) for n in node_list}
   120   2273.2 MiB      0.0 MiB        9920       neighbor_degs = [
   121   2273.2 MiB      0.9 MiB      129280           np.mean([node_degree_dict[m] for m in egonets[n].nodes if m != n])
   122   2273.2 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   123                                                 else 0
   124   2273.2 MiB      0.0 MiB        9917           for n in node_list
   125                                             ]
   126   2273.2 MiB      0.0 MiB           1       node_features[:, 1] = neighbor_degs
   127   2273.4 MiB      0.2 MiB           1       return np.nan_to_num(node_features)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   5917.1 MiB   5917.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   5917.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   6671.9 MiB    754.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   5917.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   5917.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   5917.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6671.5 MiB   6671.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6671.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.3 MiB    750.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6671.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6671.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6671.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.1 MiB   6672.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.0 MiB    749.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.1 MiB    749.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6671.9 MiB   6671.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6671.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.2 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6671.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6671.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6671.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.8 MiB   6672.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.2 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6671.5 MiB   6671.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6671.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.0 MiB    751.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6671.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6671.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6671.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.4 MiB   6672.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.3 MiB    749.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.2 MiB   6672.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    751.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.4 MiB   6672.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.7 MiB   6672.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.3 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.8 MiB   6672.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.7 MiB    749.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.5 MiB   6673.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.8 MiB   6672.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.7 MiB   6673.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.4 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.7 MiB   6672.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.8 MiB    751.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.4 MiB   6673.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.5 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.6 MiB   6673.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.6 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.5 MiB   6673.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.8 MiB   6672.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.0 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.8 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.3 MiB   6672.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.7 MiB   6673.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.2 MiB   6673.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.6 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.0 MiB    749.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6671.7 MiB   6671.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6671.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    751.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6671.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6671.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6671.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.3 MiB   6673.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.5 MiB    749.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.7 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.0 MiB    749.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.5 MiB    749.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.8 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.6 MiB   6672.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.0 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.0 MiB   6673.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.6 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6674.0 MiB   6674.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6674.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    749.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6674.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6674.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6674.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.6 MiB   6672.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.5 MiB    750.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.3 MiB   6673.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.8 MiB   6672.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.6 MiB   6673.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    749.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.4 MiB   6673.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.7 MiB   6672.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.2 MiB    749.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.0 MiB   6673.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    749.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.6 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.7 MiB   6672.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.0 MiB   6673.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.4 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.8 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.6 MiB   6673.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7424.1 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.8 MiB   6672.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.6 MiB   6672.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.7 MiB   6672.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.0 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.5 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.3 MiB   6673.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.4 MiB    749.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.9 MiB   6673.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.5 MiB    748.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.6 MiB    751.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.3 MiB   6673.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.4 MiB   6672.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.9 MiB    751.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.4 MiB   6673.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.3 MiB   6673.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7424.0 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.0 MiB   6673.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.8 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7424.1 MiB    751.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.2 MiB   6672.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.9 MiB    751.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.2 MiB   6672.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7424.1 MiB    751.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.8 MiB   6673.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.3 MiB    748.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.5 MiB   6673.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.7 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.6 MiB   6672.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7424.3 MiB    751.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.0 MiB   6672.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.4 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.1 MiB   6672.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    751.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.1 MiB   6673.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.6 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.1 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6674.0 MiB   6674.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6674.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    749.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6674.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6674.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6674.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6674.0 MiB   6674.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6674.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.4 MiB    748.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6674.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6674.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6674.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.4 MiB   6672.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.9 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.0 MiB   6673.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.2 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.4 MiB   6673.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.5 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.4 MiB   6672.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.5 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6671.9 MiB   6671.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6671.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.7 MiB    751.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6671.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6671.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6671.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.6 MiB   6672.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7424.0 MiB    751.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.9 MiB   6672.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.3 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.5 MiB   6673.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.4 MiB    748.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.2 MiB   6673.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.5 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.2 MiB   6672.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.9 MiB    751.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.3 MiB   6673.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.7 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.6 MiB   6673.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.4 MiB    748.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.2 MiB   6672.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.8 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6672.5 MiB   6672.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6672.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7423.5 MiB    751.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6672.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6672.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6672.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6673.7 MiB   6673.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6673.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7422.2 MiB    748.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6673.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6673.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6673.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   344   6673.5 MiB   6673.5 MiB           1   @profile
   345                                         def convertToPermHungarian(M, n1, n2):
   346                                         
   347   6673.5 MiB      0.0 MiB           1       row_ind, col_ind = scipy.optimize.linear_sum_assignment(M, maximize=True)
   348   6673.5 MiB      0.0 MiB           1       n = len(M)
   349   6673.5 MiB      0.0 MiB           1       P = np.zeros((n2, n1))
   350   6673.5 MiB      0.0 MiB           1       ans = []
   351   6712.0 MiB      0.8 MiB        9917       for i in range(n):
   352   6712.0 MiB     37.2 MiB        9916           P[row_ind[i]][col_ind[i]] = 1
   353   6712.0 MiB      0.0 MiB        9916           if (row_ind[i] >= n1) or (col_ind[i] >= n2):
   354                                                     continue
   355   6712.0 MiB      0.6 MiB        9916           ans.append((row_ind[i], col_ind[i]))
   356   6712.0 MiB      0.0 MiB           1       return P, row_ind,col_ind


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   242   2884.2 MiB   2884.2 MiB           1   @profile
   243                                         def convex_init(A, B, D, mu, niter, n1):
   244   2884.3 MiB      0.1 MiB           1       n = len(A)
   245   2884.3 MiB      0.0 MiB           1       m = len(B)
   246                                             #P = torch.eye(n, dtype = torch.float64)
   247   2884.3 MiB      0.0 MiB           1       ones = torch.ones(n, dtype = torch.float64)
   248   3627.3 MiB    743.0 MiB           1       mat_ones = torch.ones((n, n), dtype = torch.float64)
   249   3627.3 MiB      0.0 MiB           1       reg = 1.0
   250   4379.8 MiB    752.5 MiB           1       P = torch.ones((n,n), dtype = torch.float64)
   251   4383.0 MiB      3.1 MiB           1       P = P/n
   252                                             #start = time.time()
   253   5133.1 MiB    750.1 MiB           1       K=mu*D
   254   6674.0 MiB     -8.6 MiB          11       for i in range(niter):
   255   6674.0 MiB    -95.2 MiB         110           for it in range(1, 11):
   256                                                     
   257   6674.0 MiB    695.7 MiB         100               G = (torch.mm(torch.mm(A.T, A), P) - torch.mm(torch.mm(A.T, P), B) - torch.mm(torch.mm(A, P), B.T) + torch.mm(torch.mm(P, B), B.T))/2 + mu*D + i*(mat_ones - 2*P)
   258                                                     #G=-torch.mm(torch.mm(A.T, P), B)-torch.mm(torch.mm(A, P), B.T)+ K+ i*(mat_ones - 2*P)
   259   6674.2 MiB    669.6 MiB         100               q = sinkhorn(ones, ones, G, reg, maxIter = 500, stopThr = 1e-03)
   260                                                     
   261                                                     #q = ot.sinkhorn(ones, ones, G, reg, numItermax = 1000, stopThr = 1e-5)
   262                                         
   263   6674.2 MiB    -75.7 MiB         100               alpha = 2.0 / float(2.0 + it)
   264                                                     
   265   6674.0 MiB    -73.5 MiB         100               P = P + alpha * (q - P)
   266                                             #end = time.time()
   267                                             #print(end-start)
   268   6712.3 MiB     38.2 MiB           1       P2,row_ind,col_ind = convertToPermHungarian(P, m, n)
   269   6712.3 MiB      0.0 MiB           1       P2 = torch.from_numpy(P2)
   270   6714.1 MiB      1.9 MiB           1       forbnorm = LA.norm(A[:n1,:n1] - (P2@B@P2.T)[:n1,:n1], 'fro')**2
   271   6714.1 MiB      0.0 MiB           1       return P, forbnorm,row_ind,col_ind


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   400    608.0 MiB    608.0 MiB           1   @profile
   401                                         def align_new(Gq, Gt, mu=1, niter=10,weight=1):
   402    608.0 MiB      0.0 MiB           1       n1 = len(Gq.nodes())
   403    608.0 MiB      0.0 MiB           1       n2 = len(Gt.nodes())
   404    608.0 MiB      0.0 MiB           1       n = max(n1, n2)
   405    608.0 MiB      0.0 MiB          45       for i in range(n1, n):
   406    608.0 MiB      0.0 MiB          44           Gq.add_node(i)
   407    608.0 MiB      0.0 MiB          44           Gq.add_edge(i,i)
   408    608.0 MiB      0.0 MiB           1       for i in range(n2, n):
   409                                                 Gt.add_node(i)
   410                                         
   411   1355.3 MiB    747.3 MiB           1       A = torch.tensor(nx.to_numpy_array(Gq), dtype = torch.float64)
   412   2108.2 MiB    752.9 MiB           1       B = torch.tensor(nx.to_numpy_array(Gt), dtype = torch.float64)
   413   2124.5 MiB     16.3 MiB           1       F1 = feature_extraction1(Gq)
   414   2129.7 MiB      5.2 MiB           1       F2 = feature_extraction1(Gt)
   415                                             #F1 = feature_extraction(Gq)
   416                                             #F2 = feature_extraction(Gt)
   417   2882.5 MiB    752.8 MiB           1       D = torch.zeros((n,n),dtype = torch.float64)
   418                                             #D=eucledian_dist(F1,F2,n)    
   419                                             #D = torch.tensor(D, dtype = torch.float64)
   420                                             
   421   2882.5 MiB      0.0 MiB           1       if(weight==0):
   422                                                 D = torch.zeros((n,n),dtype = torch.float64)
   423   2882.5 MiB      0.0 MiB           1       elif(weight==1):
   424   2885.2 MiB      2.6 MiB           1           D = torch.zeros((n,n),dtype = torch.float64)
   425   2884.2 MiB     -1.0 MiB           1           D = eucledian_dist(F1,F2,n)
   426                                             elif(weight==1.5):
   427                                                 D = torch.zeros((n,n),dtype = torch.float64)
   428                                                 D = eucledian_dist(F1,F2,n)
   429                                                 D = eucledian_dist2(F1,F2,D,1.5)
   430                                             elif(weight==2):
   431                                                 D = torch.zeros((n,n),dtype = torch.float64)
   432                                                 D = eucledian_dist(F1,F2,n)
   433                                                 D = eucledian_dist2(F1,F2,D,2)
   434                                             else:
   435                                                 D = torch.zeros((n,n),dtype = torch.float64)
   436                                                 D = eucledian_dist(F1,F2,n)     
   437                                                 D = euclidean_dist1(F1,F2,D,np.max(D))
   438   3674.7 MiB    790.5 MiB           1       P, forbnorm,row_ind,col_ind = convex_init(A, B, D, mu, niter, n1)
   439   4420.6 MiB    745.9 MiB           1       _, ans=convertToPermHungarian2new(row_ind,col_ind, n1, n2)
   440                                             #_, ans = convertToPermHungarian2(P, n1, n2)
   441   4420.6 MiB      0.0 MiB           1       list_of_nodes = []
   442   4420.6 MiB      0.0 MiB        9873       for el in ans: list_of_nodes.append(el[1])
   443   4420.6 MiB      0.0 MiB           1       return ans, list_of_nodes, forbnorm


----  Alpine_Dummy ----
----> Forb_norm: 133606.0
----> Accuracy: 0.037944664031620556
----> Spec_norm: 0
----> Time: 3163.509705066681
----> Isomorphic: False






Filename: PartialTest.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    385.0 MiB    385.0 MiB           1   @profile
    29                                         def RunExp():
    30    385.0 MiB      0.0 MiB           1       plotall = False
    31                                         
    32    385.0 MiB      0.0 MiB           1       folderall = 'data3_'
    33                                         
    34                                         
    35    385.0 MiB      0.0 MiB           1       foldernames = [ 'arenas','netscience', 'multimanga', 'highschool', 'voles']
    36    385.0 MiB      0.0 MiB           1       n_G = [ 1133,379, 1004, 327, 712]
    37                                             #foldernames = [  'douban']
    38                                             #n_G = [  3906]
    39    385.0 MiB      0.0 MiB           1       foldernames = [ 'netscience']
    40    385.0 MiB      0.0 MiB           1       n_G = [ 379]
    41                                             #foldernames=["random/subgraph_DG_80","random/subgraph_DG_160","random/subgraph_DG_320","random/subgraph_DG_640","random/subgraph_DG_1280","random/subgraph_DG_2560","random/subgraph_DG_5120"]
    42                                             #foldernames1=["random/subgraph_QG_80","random/subgraph_QG_160","random/subgraph_DG_QG","random/subgraph_QG_640","random/subgraph_QG_1280","random/subgraph_QG_2560","random/subgraph_QG_5120"]
    43                                             #n_G = [ 80,160,320,640,1280,2560,5120]
    44                                             #foldernames=["random/subgraph_DG_5120"]
    45                                             #foldernames1=["random/subgraph_QG_5120"]
    46                                             #n_G = [5120]
    47                                             #foldernames = [ 'highschool']
    48                                             #n_G = [ 327]
    49                                             #foldernames = [  'highschool']
    50                                             #n_G = [ 327]
    51                                             #n_G = [575,5002,11586]
    52                                             #n_GQ = [453,4623,8325]
    53                                             #n_GT = [437,4483,7555]
    54                                         
    55                                             #foldernames = [ 'male','route','sp']
    56                                             #n_G = [575]
    57                                             #n_G=[5003]
    58                                             #foldernames = ['facebook']
    59                                             #9916
    60                                             #9871
    61    385.0 MiB      0.0 MiB           1       iters =1
    62    385.0 MiB      0.0 MiB          12       percs = [(i+1)/10 for i in range(0,9)]
    63    385.0 MiB      0.0 MiB           1       percs=[0.1]
    64                                             #tun=[1,2,3,4,5,6,7]
    65    385.0 MiB      0.0 MiB           1       tuns=["Alpine","Cone","SGWL","Alpine_Dummy","Grampa","Regal","Fugal","mcmc","GradP"]
    66    385.0 MiB      0.0 MiB           1       tun=[1,2,3,4,5,6,8,9,10]
    67    385.0 MiB      0.0 MiB           1       tuns=["Alpine_Dummy"]
    68    385.0 MiB      0.0 MiB           1       tun=[4]
    69                                             #tuns=["Alpine_Dummy","Grad","mcmc"]
    70                                         
    71                                         
    72                                             #tun = [1,8,10]
    73                                             #nL=["_Noise5","_Noise10","_Noise15","_Noise20","_Noise25"]
    74                                             #tuns=["Alpine"]
    75                                             #tun=[4,8]
    76                                         
    77                                             #tun = [1]
    78                                             #n_G = [4039]
    79                                             #n_GQ = [9872]
    80                                             #n_GT = [9872]
    81                                         
    82                                             #n_G = [1043]
    83                                             #n_GQ = [1000]
    84                                             #n_GT = [1000]
    85                                         
    86                                             #foldernames = ['sp']
    87    385.0 MiB      0.0 MiB           1       foldernames = [ 'dblp']
    88    385.0 MiB      0.0 MiB           1       n_G = [9916]
    89    782.6 MiB      0.0 MiB           2       def printR(name,forb_norm,accuracy,spec_norm,time_diff,isomorphic=False):
    90    782.6 MiB      0.0 MiB           1           print('---- ',name, '----')
    91    782.6 MiB      0.0 MiB           1           print('----> Forb_norm:', forb_norm)
    92    782.6 MiB      0.0 MiB           1           print('----> Accuracy:', accuracy)
    93    782.6 MiB      0.0 MiB           1           print('----> Spec_norm:', spec_norm)
    94    782.6 MiB      0.0 MiB           1           print('----> Time:', time_diff)
    95    782.6 MiB      0.0 MiB           1           print('----> Isomorphic:', isomorphic)
    96    782.6 MiB      0.0 MiB           1           print()     
    97                                         
    98    385.0 MiB      0.0 MiB           1       experimental_folder=f'./{folderall}/res/'
    99    385.2 MiB      0.2 MiB           1       new_id = generate_new_id(get_max_previous_id(experimental_folder))
   100    385.2 MiB      0.0 MiB           1       experimental_folder=f'./{folderall}/res/_{new_id}/'   
   101    385.2 MiB      0.0 MiB           1       DGS=0
   102    385.2 MiB      0.0 MiB           1       DGES=0
   103    385.2 MiB      0.0 MiB           1       QGS=0
   104    385.2 MiB      0.0 MiB           1       QGES=0
   105    385.2 MiB      0.0 MiB           1       PGS=0
   106    385.2 MiB      0.0 MiB           1       PGES=0         
   107    782.6 MiB      0.0 MiB           2       for k in range(0,len(foldernames)):
   108    406.2 MiB     21.0 MiB           1               G = read_real_graph(n = n_G[k], name_ = f'./raw_data/{foldernames[k]}.txt')
   109    406.2 MiB      0.0 MiB           1               print(G)
   110    406.2 MiB      0.0 MiB           1               DGS=G.number_of_nodes()
   111                                         
   112                                             # Get the number of edges
   113    406.2 MiB      0.0 MiB           1               DGES = G.number_of_edges()
   114                                                     
   115                                                     #perc=percs[0]
   116    782.6 MiB      0.0 MiB           2               for perc in percs: 
   117    782.6 MiB      0.0 MiB           2                   for ptun in range(len(tun)): 
   118    406.2 MiB      0.0 MiB           1                       folder = f'./{folderall}/{foldernames[k]}/{int(perc*100)}'
   119    406.2 MiB      0.0 MiB           1                       os.makedirs(f'{experimental_folder}{foldernames[k]}/{int(perc*100)}', exist_ok=True)
   120    406.2 MiB      0.0 MiB           1                       folder1=f'./{experimental_folder}/{foldernames[k]}/{int(perc*100)}'
   121    406.2 MiB      0.0 MiB           1                       file_A_results = open(f'{folder1}/SizeTest_results{tuns[ptun]}.txt', 'w')
   122    406.2 MiB      0.0 MiB           1                       file_A_results.write(f'DGS DGES QGS QGES PGS PGES forb_norm accuracy spec_norm time isomorphic \n')
   123                                                             
   124    406.2 MiB      0.0 MiB           1                       file_real_spectrum = open(f'{folder1}/real_Tspectrum{tuns[ptun]}.txt', 'w')
   125    406.2 MiB      0.0 MiB           1                       file_A_spectrum = open(f'{folder1}/A_Tspectrum{tuns[ptun]}.txt', 'w')
   126    406.2 MiB      0.0 MiB           1                       n_Q = int(perc*G.number_of_nodes())
   127                                                             #n_Q=n_GQ[k]#9872
   128    406.2 MiB      0.0 MiB           1                       n_Q = 9872 
   129    406.2 MiB      0.0 MiB           1                       print(f'Size of subgraph: {n_Q}')
   130    782.6 MiB      0.0 MiB           2                       for iter in range(iters):
   131    406.2 MiB      0.0 MiB           1                           folder_ = f'{folder}/{iter}'
   132    406.2 MiB      0.0 MiB           1                           folder1_ = f'{folder1}/{iter}'
   133                                                                 #folder_ = f'{folder}'
   134    406.2 MiB      0.0 MiB           1                           os.makedirs(f'{folder1_}', exist_ok=True)
   135    406.2 MiB      0.0 MiB           1                           file_subgraph = f'{folder_}/subgraph.txt'
   136    406.2 MiB      0.0 MiB           1                           file_nodes = f'{folder_}/nodes.txt'
   137                                                                 #file_subgraph = f'raw_data/random/subgraph_QG_{n_G[k]}.txt'
   138                                                                 #file_nodes = f'raw_data/random/nodes_QG_{n_G[k]}.txt'
   139    406.2 MiB      0.0 MiB           1                           Q_real = read_list(file_nodes)
   140    406.2 MiB      0.0 MiB           1                           print(f'Reading subgraph at {file_subgraph}')
   141    406.2 MiB      0.0 MiB           1                           print(f'Reading alignment at {file_nodes}')
   142    424.9 MiB     18.7 MiB           1                           G_Q= read_real_graph(n = n_Q, name_ = file_subgraph)
   143    576.8 MiB    151.9 MiB           1                           A = nx.adjacency_matrix(G_Q).todense()
   144    576.8 MiB      0.0 MiB           1                           print(G_Q)
   145                                                                 #print(Q_real)
   146    576.8 MiB      0.0 MiB           1                           QGS=G_Q.number_of_nodes()
   147    576.8 MiB      0.0 MiB           1                           QGES = G_Q.number_of_edges()
   148                                                                 #L = np.diag(np.array(np.sum(A, axis = 0)))
   149                                                                 #eigv_G_Q, _ = linalg.eig(L - A)
   150                                                                 #idx = eigv_G_Q.argsort()[::]   
   151                                                                 #eigv_G_Q = eigv_G_Q[idx]
   152                                                                 #for el in eigv_G_Q: file_real_spectrum.write(f'{el} ')
   153                                                                 #file_real_spectrum.write(f'\n')
   154    576.8 MiB      0.0 MiB           1                           start = time.time()
   155    576.8 MiB      0.0 MiB           1                           if(tun[ptun]==1):
   156                                                                     print("Alpine")
   157                                                                     _, list_of_nodes, forb_norm = Alpine(G_Q.copy(), G.copy(),mu=1,weight=2)
   158    576.8 MiB      0.0 MiB           1                           elif(tun[ptun]==2):
   159                                                                     print("Cone")
   160                                                                     _, list_of_nodes, forb_norm = coneGAM(G_Q.copy(), G.copy())
   161    576.8 MiB      0.0 MiB           1                           elif(tun[ptun]==3):
   162                                                                     print("SGWL")
   163                                                                     _, list_of_nodes, forb_norm = SGWLSA(G_Q.copy(), G.copy())
   164    576.8 MiB      0.0 MiB           1                           elif(tun[ptun]==4):
   165    576.8 MiB      0.0 MiB           1                               print("Alpine_Dummy")
   166    673.0 MiB     96.2 MiB           1                               _, list_of_nodes, forb_norm = align_new(G_Q.copy(), G.copy(),mu=1,weight=1)
   167                                                                 elif(tun[ptun]==5):
   168                                                                     print("Grampa")
   169                                                                     _, list_of_nodes, forb_norm = Grampa(G_Q.copy(), G.copy())
   170                                                                 elif(tun[ptun]==6):
   171                                                                     print("Regal")
   172                                                                     _, list_of_nodes, forb_norm = Regal(G_Q.copy(), G.copy())      
   173                                                                 elif(tun[ptun]==7):
   174                                                                     print("MDS")
   175                                                                     _, list_of_nodes, forb_norm = MDSGA(G_Q.copy(), G.copy())
   176                                                                 elif(tun[ptun]==8):
   177                                                                     print("fugal")
   178                                                                     _,list_of_nodes, forb_norm = Fugal(G_Q.copy(), G.copy())
   179                                                                 elif(tun[ptun]==9):
   180                                                                     print("mcmc")
   181                                                                     list_of_nodes, forb_norm = mcAlign(G_Q.copy(), G.copy(),Q_real)
   182                                                                 elif(tun[ptun]==10):
   183                                                                     print("GradAlignP")
   184                                                                     list_of_nodes, forb_norm = gradPMain(G_Q.copy(), G.copy())
   185                                                                 else:
   186                                                                     print("NO given algorithm ID")
   187                                                                     exit()
   188    673.0 MiB      0.0 MiB           1                           end = time.time()
   189    673.0 MiB      0.0 MiB           1                           subgraph = G.subgraph(list_of_nodes)
   190                                                                 
   191    673.0 MiB      0.0 MiB           1                           PGS=subgraph.number_of_nodes()
   192    673.0 MiB      0.0 MiB           1                           PGES = subgraph.number_of_edges()
   193    673.0 MiB      0.0 MiB           1                           isomorphic=False
   194    673.0 MiB      0.0 MiB           1                           if(forb_norm==0):
   195                                                                     isomorphic=True
   196    673.0 MiB      0.0 MiB           1                           time_diff = end - start
   197    673.0 MiB      0.0 MiB           1                           file_nodes_pred = open(f'{folder1_}/{tuns[ptun]}.txt','w')
   198    673.0 MiB      0.0 MiB        9873                           for node in list_of_nodes: file_nodes_pred.write(f'{node}\n')
   199    744.2 MiB     71.1 MiB           1                           A = nx.adjacency_matrix(nx.induced_subgraph(G, list_of_nodes)).todense()
   200    782.6 MiB     38.4 MiB           1                           L = np.diag(np.array(np.sum(A, axis = 0)))
   201                                         
   202                                         
   203                                                                 #   accuracy = np.sum(np.array(Q_real)==np.array(list_of_nodes))/len(Q_real)
   204    782.6 MiB      0.0 MiB           1                           accuracy = np.sum(np.array(Q_real)==np.array(list_of_nodes))/1265
   205                                                                 #len(Q_real)
   206    782.6 MiB      0.0 MiB           1                           spec_norm=0
   207    782.6 MiB      0.0 MiB           1                           file_A_results.write(f'{DGS} {DGES} {QGS} {QGES} {PGS} {PGES} {forb_norm} {accuracy} {spec_norm} {time_diff} {isomorphic}\n')
   208    782.6 MiB      0.0 MiB           1                           printR(tuns[ptun],forb_norm,accuracy,0,time_diff,isomorphic)            
   209    782.6 MiB      0.0 MiB           1                   print('\n')
   210    782.6 MiB      0.0 MiB           1               print('\n\n')


