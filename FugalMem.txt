687
Created new folder: ./data3_/res/_687
set seed: 5
Making ./raw_data/dblp.txt graph...
Done ./raw_data/dblp.txt Peter...
Graph with 9916 nodes and 44808 edges
Size of subgraph: 9872
Reading subgraph at ./data3_/dblp/10/0/subgraph.txt
Reading alignment at ./data3_/dblp/10/0/nodes.txt
Making ./data3_/dblp/10/0/subgraph.txt graph...
Done ./data3_/dblp/10/0/subgraph.txt Peter...
Graph with 9872 nodes and 39561 edges
fugal
Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   129   2109.4 MiB   2109.4 MiB           1   @profile
   130                                         def feature_extraction(G,simple = True):
   131                                             """Node feature extraction.
   132                                         
   133                                             Parameters
   134                                             ----------
   135                                         
   136                                             G (nx.Graph): a networkx graph.
   137                                         
   138                                             Returns
   139                                             -------
   140                                         
   141                                             node_features (float): the Nx7 matrix of node features."""
   142                                             #G = standardize_nodes(G)
   143                                             # necessary data structures
   144   2109.4 MiB      0.0 MiB           1       node_features = np.zeros(shape=(G.number_of_nodes(), 7))
   145   2109.4 MiB      0.0 MiB           1       node_list = sorted(G.nodes())
   146   2109.4 MiB      0.0 MiB           1       node_degree_dict = dict(G.degree())
   147   2109.7 MiB      0.3 MiB           1       node_clustering_dict = dict(nx.clustering(G))
   148   2251.5 MiB    141.8 MiB        9919       egonets = {n: nx.ego_graph(G, n) for n in node_list}
   149                                         
   150                                             # node degrees
   151   2251.6 MiB      0.1 MiB        9919       degs = [node_degree_dict[n] for n in node_list]
   152                                         
   153                                             # clustering coefficient
   154   2251.7 MiB      0.1 MiB        9919       clusts = [node_clustering_dict[n] for n in node_list]
   155                                         
   156                                             # average degree of neighborhood
   157   2252.6 MiB      0.0 MiB        9920       neighbor_degs = [
   158   2252.5 MiB      0.9 MiB      118786           np.mean([node_degree_dict[m] for m in egonets[n].nodes if m != n])
   159   2252.5 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   160                                                 else 0
   161   2252.5 MiB      0.0 MiB        9917           for n in node_list
   162                                             ]
   163                                         
   164                                             # average clustering coefficient of neighborhood
   165   2252.9 MiB      0.0 MiB        9920       neighbor_clusts = [
   166   2252.9 MiB      0.3 MiB      118786           np.mean([node_clustering_dict[m] for m in egonets[n].nodes if m != n])
   167   2252.9 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   168                                                 else 0
   169   2252.9 MiB      0.0 MiB        9917           for n in node_list
   170                                             ]
   171                                         
   172                                             # number of edges in the neighborhood
   173                                         
   174   2252.9 MiB      0.0 MiB           1       if simple==False:
   175                                                 neighbor_edges = [
   176                                                     egonets[n].number_of_edges() if node_degree_dict[n] > 0 else 0
   177                                                     for n in node_list
   178                                                 ]
   179                                         
   180                                             # number of outgoing edges from the neighborhood
   181                                             # the sum of neighborhood degrees = 2*(internal edges) + external edges
   182                                             # node_features[:,5] = node_features[:,0] * node_features[:,2] - 2*node_features[:,4]
   183   2252.9 MiB      0.0 MiB           1       if simple==False:
   184                                                 neighbor_outgoing_edges = [
   185                                                     len(
   186                                                         [
   187                                                             edge
   188                                                             for edge in set.union(*[set(G.edges(j)) for j in egonets[i].nodes])
   189                                                             if not egonets[i].has_edge(*edge)
   190                                                         ]
   191                                                     )
   192                                                     for i in node_list
   193                                                 ]   
   194                                         
   195                                             # number of neighbors of neighbors (not in neighborhood)
   196   2252.9 MiB      0.0 MiB           1       if simple==False:
   197                                                 neighbors_of_neighbors = [
   198                                                     len(
   199                                                         set([p for m in G.neighbors(n) for p in G.neighbors(m)])
   200                                                         - set(G.neighbors(n))
   201                                                         - set([n])
   202                                                     )
   203                                                     if node_degree_dict[n] > 0
   204                                                     else 0
   205                                                     for n in node_list
   206                                                 ]
   207                                         
   208                                             # assembling the features
   209   2252.9 MiB      0.0 MiB           1       node_features[:, 0] = degs
   210   2252.9 MiB      0.0 MiB           1       node_features[:, 1] = clusts
   211   2252.9 MiB      0.0 MiB           1       node_features[:, 2] = neighbor_degs
   212   2252.9 MiB      0.0 MiB           1       node_features[:, 3] = neighbor_clusts
   213   2252.9 MiB      0.0 MiB           1       if (simple==False):
   214                                                 node_features[:, 4] = neighbor_edges #create if statement
   215                                                 node_features[:, 5] = neighbor_outgoing_edges#
   216                                                 node_features[:, 6] = neighbors_of_neighbors#
   217                                         
   218   2253.8 MiB      0.9 MiB           1       node_features = np.nan_to_num(node_features)
   219   2253.8 MiB      0.0 MiB           1       return np.nan_to_num(node_features)


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   129   2127.8 MiB   2127.8 MiB           1   @profile
   130                                         def feature_extraction(G,simple = True):
   131                                             """Node feature extraction.
   132                                         
   133                                             Parameters
   134                                             ----------
   135                                         
   136                                             G (nx.Graph): a networkx graph.
   137                                         
   138                                             Returns
   139                                             -------
   140                                         
   141                                             node_features (float): the Nx7 matrix of node features."""
   142                                             #G = standardize_nodes(G)
   143                                             # necessary data structures
   144   2127.8 MiB      0.0 MiB           1       node_features = np.zeros(shape=(G.number_of_nodes(), 7))
   145   2127.8 MiB      0.0 MiB           1       node_list = sorted(G.nodes())
   146   2127.8 MiB      0.0 MiB           1       node_degree_dict = dict(G.degree())
   147   2127.8 MiB      0.0 MiB           1       node_clustering_dict = dict(nx.clustering(G))
   148   2274.5 MiB    146.7 MiB        9919       egonets = {n: nx.ego_graph(G, n) for n in node_list}
   149                                         
   150                                             # node degrees
   151   2274.6 MiB      0.0 MiB        9919       degs = [node_degree_dict[n] for n in node_list]
   152                                         
   153                                             # clustering coefficient
   154   2274.7 MiB      0.1 MiB        9919       clusts = [node_clustering_dict[n] for n in node_list]
   155                                         
   156                                             # average degree of neighborhood
   157   2275.6 MiB      0.0 MiB        9920       neighbor_degs = [
   158   2275.6 MiB      0.9 MiB      129280           np.mean([node_degree_dict[m] for m in egonets[n].nodes if m != n])
   159   2275.6 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   160                                                 else 0
   161   2275.6 MiB      0.0 MiB        9917           for n in node_list
   162                                             ]
   163                                         
   164                                             # average clustering coefficient of neighborhood
   165   2275.9 MiB      0.0 MiB        9920       neighbor_clusts = [
   166   2275.9 MiB      0.4 MiB      129280           np.mean([node_clustering_dict[m] for m in egonets[n].nodes if m != n])
   167   2275.9 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   168                                                 else 0
   169   2275.9 MiB      0.0 MiB        9917           for n in node_list
   170                                             ]
   171                                         
   172                                             # number of edges in the neighborhood
   173                                         
   174   2275.9 MiB      0.0 MiB           1       if simple==False:
   175                                                 neighbor_edges = [
   176                                                     egonets[n].number_of_edges() if node_degree_dict[n] > 0 else 0
   177                                                     for n in node_list
   178                                                 ]
   179                                         
   180                                             # number of outgoing edges from the neighborhood
   181                                             # the sum of neighborhood degrees = 2*(internal edges) + external edges
   182                                             # node_features[:,5] = node_features[:,0] * node_features[:,2] - 2*node_features[:,4]
   183   2275.9 MiB      0.0 MiB           1       if simple==False:
   184                                                 neighbor_outgoing_edges = [
   185                                                     len(
   186                                                         [
   187                                                             edge
   188                                                             for edge in set.union(*[set(G.edges(j)) for j in egonets[i].nodes])
   189                                                             if not egonets[i].has_edge(*edge)
   190                                                         ]
   191                                                     )
   192                                                     for i in node_list
   193                                                 ]   
   194                                         
   195                                             # number of neighbors of neighbors (not in neighborhood)
   196   2275.9 MiB      0.0 MiB           1       if simple==False:
   197                                                 neighbors_of_neighbors = [
   198                                                     len(
   199                                                         set([p for m in G.neighbors(n) for p in G.neighbors(m)])
   200                                                         - set(G.neighbors(n))
   201                                                         - set([n])
   202                                                     )
   203                                                     if node_degree_dict[n] > 0
   204                                                     else 0
   205                                                     for n in node_list
   206                                                 ]
   207                                         
   208                                             # assembling the features
   209   2276.0 MiB      0.0 MiB           1       node_features[:, 0] = degs
   210   2276.0 MiB      0.0 MiB           1       node_features[:, 1] = clusts
   211   2276.0 MiB      0.0 MiB           1       node_features[:, 2] = neighbor_degs
   212   2276.0 MiB      0.0 MiB           1       node_features[:, 3] = neighbor_clusts
   213   2276.0 MiB      0.0 MiB           1       if (simple==False):
   214                                                 node_features[:, 4] = neighbor_edges #create if statement
   215                                                 node_features[:, 5] = neighbor_outgoing_edges#
   216                                                 node_features[:, 6] = neighbors_of_neighbors#
   217                                         
   218   2276.7 MiB      0.7 MiB           1       node_features = np.nan_to_num(node_features)
   219   2276.7 MiB      0.0 MiB           1       return np.nan_to_num(node_features)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   5921.2 MiB   5921.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   5921.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   6676.9 MiB    755.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   5921.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   5921.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   5921.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.1 MiB   6678.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.6 MiB    749.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7426.7 MiB    748.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.8 MiB   6677.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.5 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.8 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.1 MiB   6677.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.6 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6676.2 MiB   6676.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6676.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.8 MiB    752.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6676.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6676.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6676.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.5 MiB   6677.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.9 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.9 MiB   6678.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.8 MiB   6677.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    751.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.5 MiB   6678.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.9 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.6 MiB   6678.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.2 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.0 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.1 MiB   6679.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    749.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.1 MiB   6678.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.8 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.6 MiB   6678.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.0 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.6 MiB   6678.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.9 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.0 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.8 MiB   6678.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.5 MiB   6678.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.8 MiB   6678.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.2 MiB    749.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.5 MiB   6677.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    751.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.0 MiB   6679.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.2 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.2 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.8 MiB   6677.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.1 MiB    751.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.6 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.3 MiB   6677.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.3 MiB    751.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.4 MiB   6677.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    751.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.4 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.8 MiB   6678.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.2 MiB    751.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.4 MiB   6679.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.5 MiB    748.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.1 MiB   6679.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    749.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.6 MiB   6677.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    750.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.1 MiB    748.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.5 MiB   6678.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.9 MiB   6678.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    749.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    751.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.9 MiB   6678.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.2 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.4 MiB   6677.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.8 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    750.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.3 MiB   6679.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    749.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    750.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.1 MiB    751.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.8 MiB   6677.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.2 MiB    750.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.2 MiB   6678.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.1 MiB   6678.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.2 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.4 MiB   6678.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    750.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.0 MiB   6679.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.3 MiB    749.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.8 MiB   6677.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    750.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.8 MiB   6678.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.7 MiB    750.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.9 MiB   6678.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    749.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.6 MiB   6678.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.7 MiB    750.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.9 MiB   6677.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    751.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.3 MiB   6678.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.5 MiB    750.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6679.6 MiB   6679.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6679.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.3 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6679.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6679.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6679.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.6 MiB   6678.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.9 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.5 MiB   6678.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.1 MiB    749.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6677.7 MiB   6677.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6677.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.2 MiB    751.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6677.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6677.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6677.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.9 MiB   6678.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7429.0 MiB    750.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.0 MiB   6678.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.6 MiB    750.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.7 MiB   6678.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7427.2 MiB    748.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6678.1 MiB   6678.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6678.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7428.4 MiB    750.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6678.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6678.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6678.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   344   6679.0 MiB   6679.0 MiB           1   @profile
   345                                         def convertToPermHungarian(M, n1, n2):
   346                                         
   347   6679.0 MiB      0.0 MiB           1       row_ind, col_ind = scipy.optimize.linear_sum_assignment(M, maximize=True)
   348   6679.0 MiB      0.0 MiB           1       n = len(M)
   349   6679.0 MiB      0.0 MiB           1       P = np.zeros((n2, n1))
   350   6679.0 MiB      0.0 MiB           1       ans = []
   351   6717.7 MiB      1.0 MiB        9917       for i in range(n):
   352   6717.7 MiB     36.9 MiB        9916           P[row_ind[i]][col_ind[i]] = 1
   353   6717.7 MiB      0.0 MiB        9916           if (row_ind[i] >= n1) or (col_ind[i] >= n2):
   354                                                     continue
   355   6717.7 MiB      0.8 MiB        9916           ans.append((row_ind[i], col_ind[i]))
   356   6717.7 MiB      0.0 MiB           1       return P, row_ind,col_ind


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   749   2883.7 MiB   2883.7 MiB           1   @profile
   750                                         def Fugal_pp(A, B, D, mu, niter, n1):
   751   2883.7 MiB      0.0 MiB           1       n = len(A)
   752   2883.7 MiB      0.0 MiB           1       m = len(B)
   753                                             #P = torch.ones((n,n), dtype = torch.float64)
   754   3634.1 MiB    750.5 MiB           1       P = torch.rand((n,n), dtype = torch.float64)
   755   3637.4 MiB      3.3 MiB           1       P=P/n
   756   3637.4 MiB      0.0 MiB           1       ones = torch.ones(n, dtype = torch.float64)
   757   4390.4 MiB    753.0 MiB           1       mat_ones = torch.ones((n, n), dtype = torch.float64)
   758   4390.4 MiB      0.0 MiB           1       reg = 1.0
   759   5140.6 MiB    750.1 MiB           1       K=mu*D
   760                                             #P=sinkhorn(ones, ones, K, reg, maxIter = 1500, stopThr = 1e-3)
   761                                             #P=torch.zeros((n,n), dtype = torch.float64)
   762   6679.0 MiB     -8.4 MiB          11       for i in range(niter):
   763   6679.4 MiB    -94.0 MiB         110           for it in range(1, 11):
   764                                                     #G=  A.T@torch.sign(A @ P- P@B)- torch.sign(A@P-P@B) @ B.T+K+ i*( - 2*P)
   765   6679.6 MiB    696.7 MiB         100               G=-torch.mm(torch.mm(A.T, P), B)-torch.mm(torch.mm(A, P), B.T)+ K+ i*(mat_ones - 2*P)
   766   6679.5 MiB    664.0 MiB         100               q = sinkhorn(ones, ones, G, reg, maxIter = 500, stopThr = 1e-5)
   767   6679.5 MiB    -75.0 MiB         100               alpha = 2 / float(2 + it)
   768   6679.4 MiB    -78.6 MiB         100               P = P + alpha * (q - P)
   769   6717.7 MiB     38.7 MiB           1       P2,row_ind,col_ind = convertToPermHungarian(P, m, n)
   770   6717.7 MiB      0.0 MiB           1       P2 = torch.from_numpy(P2)
   771   6720.3 MiB      2.6 MiB           1       forbnorm = LA.norm(A[:n1,:n1] - (P2@B@P2.T)[:n1,:n1], 'fro')**2
   772   6720.3 MiB      0.0 MiB           1       return P, forbnorm,row_ind,col_ind


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   774    608.9 MiB    608.9 MiB           1   @profile
   775                                         def Fugal(Gq, Gt, mu=1, niter=10):
   776    608.9 MiB      0.0 MiB           1       n1 = Gq.number_of_nodes()
   777    608.9 MiB      0.0 MiB           1       n2 = Gt.number_of_nodes()
   778    608.9 MiB      0.0 MiB           1       n = max(n1, n2)
   779    608.9 MiB      0.0 MiB           1       for node in nx.isolates(Gq):
   780                                                 Gq.add_edge(node, node)
   781    608.9 MiB      0.0 MiB           1       for node in nx.isolates(Gt):
   782                                                 Gt.add_edge(node, node)
   783    608.9 MiB      0.0 MiB          45       for i in range(n1, n):
   784    608.9 MiB      0.0 MiB          44           Gq.add_node(i)
   785    608.9 MiB      0.0 MiB          44           Gq.add_edge(i,i)
   786    608.9 MiB      0.0 MiB           1       for i in range(n2, n):
   787                                                Gt.add_node(i)            
   788   1356.0 MiB    747.1 MiB           1       A = torch.tensor(nx.to_numpy_array(Gq), dtype = torch.float64)
   789   2109.4 MiB    753.4 MiB           1       B = torch.tensor(nx.to_numpy_array(Gt), dtype = torch.float64)
   790   2127.8 MiB     18.4 MiB           1       F1 = feature_extraction(Gq)
   791   2133.3 MiB      5.5 MiB           1       F2 = feature_extraction(Gt)
   792                                             #F1 = feature_extraction1(Gq)
   793                                             #F2 = feature_extraction1(Gt)
   794   2883.2 MiB    749.9 MiB           1       D = eucledian_dist(F1,F2,n)
   795                                             #print(D)
   796   3680.9 MiB    797.6 MiB           1       P, forbnorm,row_ind,col_ind = Fugal_pp(A, B, mu,D, niter,n1)
   797   4424.6 MiB    743.7 MiB           1       _, ans=convertToPermHungarian2new(row_ind,col_ind, n1, n2)
   798                                            # _, ans = convertToPermHungarian2(P, n1, n2)
   799   4424.6 MiB      0.0 MiB           1       list_of_nodes = []
   800   4424.6 MiB      0.0 MiB        9873       for el in ans: list_of_nodes.append(el[1])
   801   4424.6 MiB      0.0 MiB           1       return ans, list_of_nodes, forbnorm 


----  Fugal ----
----> Forb_norm: 69056.0
----> Accuracy: 0.3494071146245059
----> Spec_norm: 0
----> Time: 2284.123461484909
----> Isomorphic: False






Filename: PartialTest.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    385.9 MiB    385.9 MiB           1   @profile
    29                                         def RunExp():
    30    385.9 MiB      0.0 MiB           1       plotall = False
    31                                         
    32    385.9 MiB      0.0 MiB           1       folderall = 'data3_'
    33                                         
    34                                         
    35    385.9 MiB      0.0 MiB           1       foldernames = [ 'arenas','netscience', 'multimanga', 'highschool', 'voles']
    36    385.9 MiB      0.0 MiB           1       n_G = [ 1133,379, 1004, 327, 712]
    37                                             #foldernames = [  'douban']
    38                                             #n_G = [  3906]
    39    385.9 MiB      0.0 MiB           1       foldernames = [ 'netscience']
    40    385.9 MiB      0.0 MiB           1       n_G = [ 379]
    41                                             #foldernames=["random/subgraph_DG_80","random/subgraph_DG_160","random/subgraph_DG_320","random/subgraph_DG_640","random/subgraph_DG_1280","random/subgraph_DG_2560","random/subgraph_DG_5120"]
    42                                             #foldernames1=["random/subgraph_QG_80","random/subgraph_QG_160","random/subgraph_DG_QG","random/subgraph_QG_640","random/subgraph_QG_1280","random/subgraph_QG_2560","random/subgraph_QG_5120"]
    43                                             #n_G = [ 80,160,320,640,1280,2560,5120]
    44                                             #foldernames=["random/subgraph_DG_5120"]
    45                                             #foldernames1=["random/subgraph_QG_5120"]
    46                                             #n_G = [5120]
    47                                             #foldernames = [ 'highschool']
    48                                             #n_G = [ 327]
    49                                             #foldernames = [  'highschool']
    50                                             #n_G = [ 327]
    51                                             #n_G = [575,5002,11586]
    52                                             #n_GQ = [453,4623,8325]
    53                                             #n_GT = [437,4483,7555]
    54                                         
    55                                             #foldernames = [ 'male','route','sp']
    56                                             #n_G = [575]
    57                                             #n_G=[5003]
    58                                             #foldernames = ['facebook']
    59                                             #9916
    60                                             #9871
    61    385.9 MiB      0.0 MiB           1       iters =1
    62    385.9 MiB      0.0 MiB          12       percs = [(i+1)/10 for i in range(0,9)]
    63    385.9 MiB      0.0 MiB           1       percs=[0.1]
    64                                             #tun=[1,2,3,4,5,6,7]
    65    385.9 MiB      0.0 MiB           1       tuns=["Alpine","Cone","SGWL","Alpine_Dummy","Grampa","Regal","Fugal","mcmc","GradP"]
    66    385.9 MiB      0.0 MiB           1       tun=[1,2,3,4,5,6,8,9,10]
    67    385.9 MiB      0.0 MiB           1       tuns=["Fugal"]
    68    385.9 MiB      0.0 MiB           1       tun=[8]
    69                                             #tuns=["Alpine_Dummy","Grad","mcmc"]
    70                                         
    71                                         
    72                                             #tun = [1,8,10]
    73                                             #nL=["_Noise5","_Noise10","_Noise15","_Noise20","_Noise25"]
    74                                             #tuns=["Alpine"]
    75                                             #tun=[4,8]
    76                                         
    77                                             #tun = [1]
    78                                             #n_G = [4039]
    79                                             #n_GQ = [9872]
    80                                             #n_GT = [9872]
    81                                         
    82                                             #n_G = [1043]
    83                                             #n_GQ = [1000]
    84                                             #n_GT = [1000]
    85                                         
    86                                             #foldernames = ['sp']
    87    385.9 MiB      0.0 MiB           1       foldernames = [ 'dblp']
    88    385.9 MiB      0.0 MiB           1       n_G = [9916]
    89    788.8 MiB      0.0 MiB           2       def printR(name,forb_norm,accuracy,spec_norm,time_diff,isomorphic=False):
    90    788.8 MiB      0.0 MiB           1           print('---- ',name, '----')
    91    788.8 MiB      0.0 MiB           1           print('----> Forb_norm:', forb_norm)
    92    788.8 MiB      0.0 MiB           1           print('----> Accuracy:', accuracy)
    93    788.8 MiB      0.0 MiB           1           print('----> Spec_norm:', spec_norm)
    94    788.8 MiB      0.0 MiB           1           print('----> Time:', time_diff)
    95    788.8 MiB      0.0 MiB           1           print('----> Isomorphic:', isomorphic)
    96    788.8 MiB      0.0 MiB           1           print()     
    97                                         
    98    385.9 MiB      0.0 MiB           1       experimental_folder=f'./{folderall}/res/'
    99    386.0 MiB      0.1 MiB           1       new_id = generate_new_id(get_max_previous_id(experimental_folder))
   100    386.0 MiB      0.0 MiB           1       experimental_folder=f'./{folderall}/res/_{new_id}/'   
   101    386.0 MiB      0.0 MiB           1       DGS=0
   102    386.0 MiB      0.0 MiB           1       DGES=0
   103    386.0 MiB      0.0 MiB           1       QGS=0
   104    386.0 MiB      0.0 MiB           1       QGES=0
   105    386.0 MiB      0.0 MiB           1       PGS=0
   106    386.0 MiB      0.0 MiB           1       PGES=0         
   107    788.8 MiB      0.0 MiB           2       for k in range(0,len(foldernames)):
   108    407.1 MiB     21.1 MiB           1               G = read_real_graph(n = n_G[k], name_ = f'./raw_data/{foldernames[k]}.txt')
   109    407.1 MiB      0.0 MiB           1               print(G)
   110    407.1 MiB      0.0 MiB           1               DGS=G.number_of_nodes()
   111                                         
   112                                             # Get the number of edges
   113    407.1 MiB      0.0 MiB           1               DGES = G.number_of_edges()
   114                                                     
   115                                                     #perc=percs[0]
   116    788.8 MiB      0.0 MiB           2               for perc in percs: 
   117    788.8 MiB      0.0 MiB           2                   for ptun in range(len(tun)): 
   118    407.1 MiB      0.0 MiB           1                       folder = f'./{folderall}/{foldernames[k]}/{int(perc*100)}'
   119    407.1 MiB      0.0 MiB           1                       os.makedirs(f'{experimental_folder}{foldernames[k]}/{int(perc*100)}', exist_ok=True)
   120    407.1 MiB      0.0 MiB           1                       folder1=f'./{experimental_folder}/{foldernames[k]}/{int(perc*100)}'
   121    407.1 MiB      0.0 MiB           1                       file_A_results = open(f'{folder1}/SizeTest_results{tuns[ptun]}.txt', 'w')
   122    407.1 MiB      0.0 MiB           1                       file_A_results.write(f'DGS DGES QGS QGES PGS PGES forb_norm accuracy spec_norm time isomorphic \n')
   123                                                             
   124    407.1 MiB      0.0 MiB           1                       file_real_spectrum = open(f'{folder1}/real_Tspectrum{tuns[ptun]}.txt', 'w')
   125    407.1 MiB      0.0 MiB           1                       file_A_spectrum = open(f'{folder1}/A_Tspectrum{tuns[ptun]}.txt', 'w')
   126    407.1 MiB      0.0 MiB           1                       n_Q = int(perc*G.number_of_nodes())
   127                                                             #n_Q=n_GQ[k]#9872
   128    407.1 MiB      0.0 MiB           1                       n_Q = 9872 
   129    407.1 MiB      0.0 MiB           1                       print(f'Size of subgraph: {n_Q}')
   130    788.8 MiB      0.0 MiB           2                       for iter in range(iters):
   131    407.1 MiB      0.0 MiB           1                           folder_ = f'{folder}/{iter}'
   132    407.1 MiB      0.0 MiB           1                           folder1_ = f'{folder1}/{iter}'
   133                                                                 #folder_ = f'{folder}'
   134    407.1 MiB      0.0 MiB           1                           os.makedirs(f'{folder1_}', exist_ok=True)
   135    407.1 MiB      0.0 MiB           1                           file_subgraph = f'{folder_}/subgraph.txt'
   136    407.1 MiB      0.0 MiB           1                           file_nodes = f'{folder_}/nodes.txt'
   137                                                                 #file_subgraph = f'raw_data/random/subgraph_QG_{n_G[k]}.txt'
   138                                                                 #file_nodes = f'raw_data/random/nodes_QG_{n_G[k]}.txt'
   139    407.1 MiB      0.0 MiB           1                           Q_real = read_list(file_nodes)
   140    407.1 MiB      0.0 MiB           1                           print(f'Reading subgraph at {file_subgraph}')
   141    407.1 MiB      0.0 MiB           1                           print(f'Reading alignment at {file_nodes}')
   142    425.8 MiB     18.7 MiB           1                           G_Q= read_real_graph(n = n_Q, name_ = file_subgraph)
   143    577.7 MiB    151.9 MiB           1                           A = nx.adjacency_matrix(G_Q).todense()
   144    577.7 MiB      0.0 MiB           1                           print(G_Q)
   145                                                                 #print(Q_real)
   146    577.7 MiB      0.0 MiB           1                           QGS=G_Q.number_of_nodes()
   147    577.7 MiB      0.0 MiB           1                           QGES = G_Q.number_of_edges()
   148                                                                 #L = np.diag(np.array(np.sum(A, axis = 0)))
   149                                                                 #eigv_G_Q, _ = linalg.eig(L - A)
   150                                                                 #idx = eigv_G_Q.argsort()[::]   
   151                                                                 #eigv_G_Q = eigv_G_Q[idx]
   152                                                                 #for el in eigv_G_Q: file_real_spectrum.write(f'{el} ')
   153                                                                 #file_real_spectrum.write(f'\n')
   154    577.7 MiB      0.0 MiB           1                           start = time.time()
   155    577.7 MiB      0.0 MiB           1                           if(tun[ptun]==1):
   156                                                                     print("Alpine")
   157                                                                     _, list_of_nodes, forb_norm = Alpine(G_Q.copy(), G.copy(),mu=1,weight=2)
   158    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==2):
   159                                                                     print("Cone")
   160                                                                     _, list_of_nodes, forb_norm = coneGAM(G_Q.copy(), G.copy())
   161    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==3):
   162                                                                     print("SGWL")
   163                                                                     _, list_of_nodes, forb_norm = SGWLSA(G_Q.copy(), G.copy())
   164    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==4):
   165                                                                     print("Alpine_Dummy")
   166                                                                     _, list_of_nodes, forb_norm = align_new(G_Q.copy(), G.copy(),mu=1,weight=1)
   167    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==5):
   168                                                                     print("Grampa")
   169                                                                     _, list_of_nodes, forb_norm = Grampa(G_Q.copy(), G.copy())
   170    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==6):
   171                                                                     print("Regal")
   172                                                                     _, list_of_nodes, forb_norm = Regal(G_Q.copy(), G.copy())      
   173    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==7):
   174                                                                     print("MDS")
   175                                                                     _, list_of_nodes, forb_norm = MDSGA(G_Q.copy(), G.copy())
   176    577.7 MiB      0.0 MiB           1                           elif(tun[ptun]==8):
   177    577.7 MiB      0.0 MiB           1                               print("fugal")
   178    677.0 MiB     99.3 MiB           1                               _,list_of_nodes, forb_norm = Fugal(G_Q.copy(), G.copy())
   179                                                                 elif(tun[ptun]==9):
   180                                                                     print("mcmc")
   181                                                                     list_of_nodes, forb_norm = mcAlign(G_Q.copy(), G.copy(),Q_real)
   182                                                                 elif(tun[ptun]==10):
   183                                                                     print("GradAlignP")
   184                                                                     list_of_nodes, forb_norm = gradPMain(G_Q.copy(), G.copy())
   185                                                                 else:
   186                                                                     print("NO given algorithm ID")
   187                                                                     exit()
   188    677.0 MiB      0.0 MiB           1                           end = time.time()
   189    677.0 MiB      0.0 MiB           1                           subgraph = G.subgraph(list_of_nodes)
   190                                                                 
   191    677.0 MiB      0.0 MiB           1                           PGS=subgraph.number_of_nodes()
   192    677.0 MiB      0.0 MiB           1                           PGES = subgraph.number_of_edges()
   193    677.0 MiB      0.0 MiB           1                           isomorphic=False
   194    677.0 MiB      0.0 MiB           1                           if(forb_norm==0):
   195                                                                     isomorphic=True
   196    677.0 MiB      0.0 MiB           1                           time_diff = end - start
   197    677.0 MiB      0.0 MiB           1                           file_nodes_pred = open(f'{folder1_}/{tuns[ptun]}.txt','w')
   198    677.0 MiB      0.0 MiB        9873                           for node in list_of_nodes: file_nodes_pred.write(f'{node}\n')
   199    750.2 MiB     73.2 MiB           1                           A = nx.adjacency_matrix(nx.induced_subgraph(G, list_of_nodes)).todense()
   200    788.8 MiB     38.5 MiB           1                           L = np.diag(np.array(np.sum(A, axis = 0)))
   201                                         
   202                                         
   203                                                                 #   accuracy = np.sum(np.array(Q_real)==np.array(list_of_nodes))/len(Q_real)
   204    788.8 MiB      0.0 MiB           1                           accuracy = np.sum(np.array(Q_real)==np.array(list_of_nodes))/1265
   205                                                                 #len(Q_real)
   206    788.8 MiB      0.0 MiB           1                           spec_norm=0
   207    788.8 MiB      0.0 MiB           1                           file_A_results.write(f'{DGS} {DGES} {QGS} {QGES} {PGS} {PGES} {forb_norm} {accuracy} {spec_norm} {time_diff} {isomorphic}\n')
   208    788.8 MiB      0.0 MiB           1                           printR(tuns[ptun],forb_norm,accuracy,0,time_diff,isomorphic)            
   209    788.8 MiB      0.0 MiB           1                   print('\n')
   210    788.8 MiB      0.0 MiB           1               print('\n\n')


