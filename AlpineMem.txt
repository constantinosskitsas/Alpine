
Alpine
Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    96   2099.5 MiB   2099.5 MiB           1   @profile
    97                                         def feature_extraction1(G,simple = True):
    98                                             """Node feature extraction.
    99                                         
   100                                             Parameters
   101                                             ----------
   102                                         
   103                                             G (nx.Graph): a networkx graph.
   104                                         
   105                                             Returns
   106                                             -------
   107                                         
   108                                             node_features (float): the Nx7 matrix of node features."""
   109                                             #G = standardize_nodes(G)
   110                                             # necessary data structures
   111   2099.5 MiB      0.0 MiB           1       node_features = np.zeros(shape=(G.number_of_nodes(), 2))
   112   2099.5 MiB      0.0 MiB           1       node_list = sorted(G.nodes())
   113   2099.5 MiB      0.0 MiB           1       node_degree_dict = dict(G.degree())
   114                                         
   115                                             # node degrees
   116   2099.5 MiB      0.0 MiB        9876       degs = [node_degree_dict[n] for n in node_list]
   117   2099.5 MiB      0.0 MiB           1       node_features[:, 0] = degs
   118   2099.5 MiB      0.0 MiB           1       node_features = np.nan_to_num(node_features)
   119   2240.4 MiB    140.9 MiB        9876       egonets = {n: nx.ego_graph(G, n) for n in node_list}
   120   2241.3 MiB      0.0 MiB        9877       neighbor_degs = [
   121   2241.3 MiB      0.8 MiB      118614           np.mean([node_degree_dict[m] for m in egonets[n].nodes if m != n])
   122   2241.1 MiB      0.0 MiB        9873           if node_degree_dict[n] > 0
   123                                                 else 0
   124   2241.1 MiB      0.0 MiB        9874           for n in node_list
   125                                             ]
   126   2241.3 MiB      0.0 MiB           1       node_features[:, 1] = neighbor_degs
   127   2241.4 MiB      0.2 MiB           1       return np.nan_to_num(node_features)


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    96   2114.9 MiB   2114.9 MiB           1   @profile
    97                                         def feature_extraction1(G,simple = True):
    98                                             """Node feature extraction.
    99                                         
   100                                             Parameters
   101                                             ----------
   102                                         
   103                                             G (nx.Graph): a networkx graph.
   104                                         
   105                                             Returns
   106                                             -------
   107                                         
   108                                             node_features (float): the Nx7 matrix of node features."""
   109                                             #G = standardize_nodes(G)
   110                                             # necessary data structures
   111   2114.9 MiB      0.0 MiB           1       node_features = np.zeros(shape=(G.number_of_nodes(), 2))
   112   2114.9 MiB      0.0 MiB           1       node_list = sorted(G.nodes())
   113   2114.9 MiB      0.0 MiB           1       node_degree_dict = dict(G.degree())
   114                                         
   115                                             # node degrees
   116   2114.9 MiB      0.0 MiB        9919       degs = [node_degree_dict[n] for n in node_list]
   117   2114.9 MiB      0.0 MiB           1       node_features[:, 0] = degs
   118   2114.9 MiB      0.0 MiB           1       node_features = np.nan_to_num(node_features)
   119   2263.1 MiB    148.1 MiB        9919       egonets = {n: nx.ego_graph(G, n) for n in node_list}
   120   2264.0 MiB     -0.2 MiB        9920       neighbor_degs = [
   121   2264.0 MiB     -1.9 MiB      129280           np.mean([node_degree_dict[m] for m in egonets[n].nodes if m != n])
   122   2264.0 MiB      0.0 MiB        9916           if node_degree_dict[n] > 0
   123                                                 else 0
   124   2264.0 MiB      0.0 MiB        9917           for n in node_list
   125                                             ]
   126   2264.0 MiB      0.0 MiB           1       node_features[:, 1] = neighbor_degs
   127   2264.1 MiB      0.1 MiB           1       return np.nan_to_num(node_features)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   6641.3 MiB   6641.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   6641.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   7393.4 MiB    752.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   6641.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   6641.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   6641.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7392.6 MiB   7392.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7392.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8139.6 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7392.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7392.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7392.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.5 MiB   7393.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.0 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7392.9 MiB   7392.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7392.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8139.7 MiB    746.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7392.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7392.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7392.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7392.1 MiB   7392.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7392.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    748.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7392.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7392.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7392.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.3 MiB   7393.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.2 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.7 MiB   7393.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.6 MiB    746.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.3 MiB   7393.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    747.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.1 MiB   7393.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.1 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.1 MiB   7393.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    747.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.3 MiB   7393.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.1 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.5 MiB   7393.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.3 MiB    747.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.2 MiB   7393.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.2 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.6 MiB    746.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.8 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.3 MiB   7394.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.6 MiB   7393.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    747.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.2 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.6 MiB   7393.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.1 MiB   7394.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    746.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.2 MiB    747.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.3 MiB   7394.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    746.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.2 MiB   7393.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.4 MiB    748.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.2 MiB    747.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.5 MiB   7394.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    747.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.5 MiB   7394.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    746.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.1 MiB   7394.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.8 MiB    747.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    746.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7395.1 MiB   7395.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7395.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    745.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7395.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7395.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7395.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.1 MiB   7393.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    747.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.7 MiB   7394.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.8 MiB    746.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.5 MiB   7394.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    745.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.3 MiB   7393.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    747.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.8 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.3 MiB   7394.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.4 MiB    746.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.1 MiB    747.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.7 MiB   7394.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    745.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.5 MiB   7393.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.4 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.4 MiB   7394.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8139.7 MiB    745.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    746.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7392.8 MiB   7392.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7392.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.1 MiB    747.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7392.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7392.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7392.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.0 MiB   7393.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.9 MiB    748.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.6 MiB    746.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.5 MiB    747.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.2 MiB    746.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.1 MiB   7394.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    746.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.2 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.1 MiB    746.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.6 MiB   7393.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    746.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.4 MiB   7394.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8139.8 MiB    745.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.3 MiB   7394.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    746.8 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.5 MiB   7394.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.4 MiB    745.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.6 MiB   7393.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    747.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8142.1 MiB    748.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    747.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.4 MiB    746.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.0 MiB    746.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.3 MiB   7393.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.6 MiB    747.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.2 MiB    747.3 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.4 MiB   7393.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8142.0 MiB    748.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    747.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.1 MiB   7393.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.6 MiB    747.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.6 MiB   7393.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.8 MiB    747.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.1 MiB    747.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.4 MiB   7393.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.1 MiB    747.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.0 MiB    746.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.1 MiB   7393.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.7 MiB    747.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.7 MiB    746.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.4 MiB    746.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.4 MiB   7393.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    747.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.1 MiB   7394.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.5 MiB   7394.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.2 MiB    745.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.7 MiB   7394.7 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.7 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    746.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.7 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.7 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.7 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.8 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.4 MiB   7393.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.4 MiB    747.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.2 MiB   7394.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.5 MiB   7394.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    745.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7392.6 MiB   7392.6 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7392.6 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.3 MiB    748.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7392.6 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7392.6 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7392.6 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.9 MiB   7394.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.3 MiB    745.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.2 MiB   7393.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.1 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.3 MiB   7393.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.0 MiB    747.7 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.5 MiB   7393.5 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.5 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.7 MiB    747.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.5 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.5 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.5 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.2 MiB    747.4 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.7 MiB    746.9 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.0 MiB   7394.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.5 MiB    746.5 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.1 MiB   7393.1 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.1 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.1 MiB    748.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.1 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.1 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.1 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.8 MiB   7393.8 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.8 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    747.1 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.8 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.8 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.8 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.3 MiB   7394.3 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.3 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.2 MiB    746.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.3 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.3 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.3 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.2 MiB   7393.2 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.2 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.4 MiB    747.2 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.2 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.2 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.2 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7395.0 MiB   7395.0 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7395.0 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.6 MiB    745.6 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7395.0 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7395.0 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7395.0 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7394.4 MiB   7394.4 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7394.4 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8141.4 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7394.4 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7394.4 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7394.4 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/sinkhorn.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   183   7393.9 MiB   7393.9 MiB           1   @profile
   184                                         def sinkhorn(a, b, C, reg=1e-1, method='sinkhorn', maxIter=1000, tau=1e3,
   185                                                      stopThr=1e-9, verbose=False, log=False, warm_start=None, eval_freq=10, print_freq=200, **kwargs):
   186                                             """
   187                                             Solve the entropic regularization optimal transport
   188                                             The input should be PyTorch tensors
   189                                             The function solves the following optimization problem:
   190                                         
   191                                             .. math::
   192                                                 \gamma = arg\min_\gamma <\gamma,C>_F + reg\cdot\Omega(\gamma)
   193                                                 s.t. \gamma 1 = a
   194                                                      \gamma^T 1= b
   195                                                      \gamma\geq 0
   196                                             where :
   197                                             - C is the (ns,nt) metric cost matrix
   198                                             - :math:`\Omega` is the entropic regularization term :math:`\Omega(\gamma)=\sum_{i,j} \gamma_{i,j}\log(\gamma_{i,j})`
   199                                             - a and b are target and source measures (sum to 1)
   200                                             The algorithm used for solving the problem is the Sinkhorn-Knopp matrix scaling algorithm as proposed in [1].
   201                                         
   202                                             Parameters
   203                                             ----------
   204                                             a : torch.tensor (na,)
   205                                                 samples measure in the target domain
   206                                             b : torch.tensor (nb,)
   207                                                 samples in the source domain
   208                                             C : torch.tensor (na,nb)
   209                                                 loss matrix
   210                                             reg : float
   211                                                 Regularization term > 0
   212                                             method : str
   213                                                 method used for the solver either 'sinkhorn', 'greenkhorn', 'sinkhorn_stabilized' or
   214                                                 'sinkhorn_epsilon_scaling', see those function for specific parameters
   215                                             maxIter : int, optional
   216                                                 Max number of iterations
   217                                             stopThr : float, optional
   218                                                 Stop threshol on error ( > 0 )
   219                                             verbose : bool, optional
   220                                                 Print information along iterations
   221                                             log : bool, optional
   222                                                 record log if True
   223                                         
   224                                             Returns
   225                                             -------
   226                                             gamma : (na x nb) torch.tensor
   227                                                 Optimal transportation matrix for the given parameters
   228                                             log : dict
   229                                                 log dictionary return only if log==True in parameters
   230                                         
   231                                             References
   232                                             ----------
   233                                             [1] M. Cuturi, Sinkhorn Distances : Lightspeed Computation of Optimal Transport, Advances in Neural Information Processing Systems (NIPS) 26, 2013
   234                                             See Also
   235                                             --------
   236                                         
   237                                             """
   238                                         
   239   7393.9 MiB      0.0 MiB           1       if method.lower() == 'sinkhorn':
   240                                                 #print('ok mphke')
   241   8140.9 MiB    747.0 MiB           3           return sinkhorn_knopp(a, b, C, reg, maxIter=maxIter,
   242   7393.9 MiB      0.0 MiB           1                                 stopThr=stopThr, verbose=verbose, log=log,
   243   7393.9 MiB      0.0 MiB           1                                 warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   244   7393.9 MiB      0.0 MiB           1                                 **kwargs)
   245                                             elif method.lower() == 'sinkhorn_stabilized':
   246                                                 return sinkhorn_stabilized(a, b, C, reg, maxIter=maxIter, tau=tau,
   247                                                                            stopThr=stopThr, verbose=verbose, log=log,
   248                                                                            warm_start=warm_start, eval_freq=eval_freq, print_freq=print_freq,
   249                                                                            **kwargs)
   250                                             elif method.lower() == 'sinkhorn_epsilon_scaling':
   251                                                 return sinkhorn_epsilon_scaling(a, b, C, reg,
   252                                                                                 maxIter=maxIter, maxInnerIter=100, tau=tau,
   253                                                                                 scaling_base=0.75, scaling_coef=None, stopThr=stopThr,
   254                                                                                 verbose=False, log=log, warm_start=warm_start, eval_freq=eval_freq,
   255                                                                                 print_freq=print_freq, **kwargs)
   256                                             else:
   257                                                 raise ValueError("Unknown method '%s'." % method)


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   344   7394.1 MiB   7394.1 MiB           1   @profile
   345                                         def convertToPermHungarian(M, n1, n2):
   346                                         
   347   7394.1 MiB      0.0 MiB           1       row_ind, col_ind = scipy.optimize.linear_sum_assignment(M, maximize=True)
   348   7394.1 MiB      0.0 MiB           1       n = len(M)
   349   7394.1 MiB      0.0 MiB           1       P = np.zeros((n2, n1))
   350   7394.1 MiB      0.0 MiB           1       ans = []
   351   7432.4 MiB      0.0 MiB        9873       for i in range(n):
   352   7432.4 MiB     36.8 MiB        9872           P[row_ind[i]][col_ind[i]] = 1
   353   7432.4 MiB      0.0 MiB        9872           if (row_ind[i] >= n1) or (col_ind[i] >= n2):
   354   7432.4 MiB      0.0 MiB          44               continue
   355   7432.4 MiB      1.5 MiB        9828           ans.append((row_ind[i], col_ind[i]))
   356   7432.4 MiB      0.0 MiB           1       return P, row_ind,col_ind


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   566   3616.1 MiB   3616.1 MiB           1   @profile
   567                                         def Alpine_pp_new(A,B, K, niter,A1,weight=1):
   568   3616.1 MiB      0.0 MiB           1       m = len(A)
   569   3616.1 MiB      0.0 MiB           1       n = len(B)
   570   4368.5 MiB    752.4 MiB           1       I_p = torch.zeros((m,m+1),dtype = torch.float64)
   571                                             #I_p2 = torch.zeros((m,m),dtype = torch.float64)
   572   4369.0 MiB      0.0 MiB        9873       for i in range(m):
   573   4369.0 MiB      0.5 MiB        9872           I_p[i,i] = 1
   574                                                 #I_p2[i,i]=1
   575   5111.8 MiB    742.8 MiB           1       Pi=torch.ones((m+1,n),dtype = torch.float64)
   576   5111.8 MiB      0.0 MiB           1       Pi[:-1,:] *= 1/n
   577   5111.8 MiB      0.0 MiB           1       Pi[-1,:] *= (n-m)/n
   578   5111.8 MiB      0.0 MiB           1       reg = 1.0
   579   5856.6 MiB    744.8 MiB           1       mat_ones = torch.ones((m+1, n), dtype = torch.float64)
   580   5856.6 MiB      0.0 MiB           1       ones_ = torch.ones(n, dtype = torch.float64)
   581   5856.6 MiB      0.0 MiB           1       ones_augm_ = torch.ones(m+1, dtype = torch.float64)
   582   5856.6 MiB      0.0 MiB           1       ones_augm_[-1] = n-m
   583                                         
   584   7394.1 MiB    -21.8 MiB          11       for i in range(10):
   585   7396.0 MiB   -186.5 MiB         110           for it in range(1, 11):
   586   7395.1 MiB    610.8 MiB         100               deriv=(-4*I_p.T@(A-I_p@Pi@B@Pi.T@I_p.T)@I_p@Pi@B)+i*(mat_ones - 2*Pi)+K
   587                                                     #q = ot.sinkhorn(ones_augm_, ones_, deriv, 1.0, numItermax = 500, stopThr = 1e-5)
   588   7395.2 MiB    653.5 MiB         100               q=sinkhorn(ones_augm_, ones_, deriv, reg,method="sinkhorn",maxIter = 500, stopThr = 1e-5) 
   589   7395.2 MiB    -99.1 MiB         100               alpha = (2 / float(2 + it) )    
   590   7396.0 MiB    -99.4 MiB         100               Pi[:m,:n] = Pi[:m,:n] + alpha * (q[:m,:n] - Pi[:m,:n])
   591   7394.1 MiB      0.0 MiB           1       Pi=Pi[:-1]
   592   7432.7 MiB     38.5 MiB           1       P2,row_ind,col_ind = convertToPermHungarian(Pi, n, m)
   593   7474.8 MiB     42.1 MiB           1       forbnorm = LA.norm(A - I_p[:,:m].T@P2@B@P2.T@I_p[:,:m], 'fro')**2
   594   7474.8 MiB      0.0 MiB           1       return Pi, forbnorm,row_ind,col_ind


Filename: /home/konstantinos/Alpine/pred.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
   711    608.6 MiB    608.6 MiB           1   @profile
   712                                         def Alpine(Gq, Gt, mu=1, niter=10, weight=2):
   713    608.6 MiB      0.0 MiB           1       n1 = Gq.number_of_nodes()
   714    608.6 MiB      0.0 MiB           1       n2 = Gt.number_of_nodes()
   715    608.6 MiB      0.0 MiB           1       n = max(n1, n2)
   716    608.6 MiB      0.0 MiB           1       for node in nx.isolates(Gq):
   717                                                 Gq.add_edge(node, node)
   718    608.6 MiB      0.0 MiB           1       for node in nx.isolates(Gt):
   719                                                 Gt.add_edge(node, node)
   720                                             
   721                                             #for i in range(n1, n):
   722                                             #    Gq.add_node(i)
   723                                             #    Gq.add_edge(i,i)
   724                                             #for i in range(n2, n):
   725                                             #   Gt.add_node(i)      
   726    608.6 MiB      0.0 MiB           1       Gq.add_node(n1)
   727    608.6 MiB      0.0 MiB           1       Gq.add_edge(n1,n1)
   728                                             #mu=0.1     
   729   1356.1 MiB    747.6 MiB           1       A = torch.tensor(nx.to_numpy_array(Gq), dtype = torch.float64)
   730   2099.5 MiB    743.4 MiB           1       B = torch.tensor(nx.to_numpy_array(Gt), dtype = torch.float64)
   731                                             #weight=1
   732   2099.5 MiB      0.0 MiB           1       if (weight==2):
   733   2114.9 MiB     15.4 MiB           1           F1 = feature_extraction1(Gq)
   734   2120.5 MiB      5.5 MiB           1           F2 = feature_extraction1(Gt) 
   735                                             else:
   736                                                 F1 = feature_extraction(Gq)
   737                                                 F2 = feature_extraction(Gt)
   738   2867.8 MiB    747.4 MiB           1       D = eucledian_dist(F1,F2,n)
   739                                             #D[-1:]*=0
   740                                             #P, forbnorm,row_ind,col_ind = Alpine_pp(A[:n1,:n1], B, mu*D, niter)
   741                                            # P, forbnorm,row_ind,col_ind = Alpine_pp(A[:n1,:n1], B, mu*D, niter,A)
   742   3704.9 MiB    837.1 MiB           1       P, forbnorm,row_ind,col_ind = Alpine_pp_new(A[:n1,:n1], B, mu*D, niter,A)
   743   4448.6 MiB    743.7 MiB           1       _, ans=convertToPermHungarian2new(row_ind,col_ind, n1, n2)
   744                                            # _, ans = convertToPermHungarian2(P, n1, n2)
   745   4448.6 MiB      0.0 MiB           1       list_of_nodes = []
   746   4448.6 MiB      0.0 MiB        9873       for el in ans: list_of_nodes.append(el[1])
   747   4448.6 MiB      0.0 MiB           1       return ans, list_of_nodes, forbnorm    


----  Alpine ----
----> Forb_norm: 57506.0
----> Accuracy: 0.45138339920948617
----> Spec_norm: 0
----> Time: 3257.0033774375916
----> Isomorphic: False






Filename: PartialTest.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
    28    385.7 MiB    385.7 MiB           1   @profile
    29                                         def RunExp():
    30    385.7 MiB      0.0 MiB           1       plotall = False
    31                                         
    32    385.7 MiB      0.0 MiB           1       folderall = 'data3_'
    33                                         
    34                                         
    35    385.7 MiB      0.0 MiB           1       foldernames = [ 'arenas','netscience', 'multimanga', 'highschool', 'voles']
    36    385.7 MiB      0.0 MiB           1       n_G = [ 1133,379, 1004, 327, 712]
    37                                             #foldernames = [  'douban']
    38                                             #n_G = [  3906]
    39    385.7 MiB      0.0 MiB           1       foldernames = [ 'netscience']
    40    385.7 MiB      0.0 MiB           1       n_G = [ 379]
    41                                             #foldernames=["random/subgraph_DG_80","random/subgraph_DG_160","random/subgraph_DG_320","random/subgraph_DG_640","random/subgraph_DG_1280","random/subgraph_DG_2560","random/subgraph_DG_5120"]
    42                                             #foldernames1=["random/subgraph_QG_80","random/subgraph_QG_160","random/subgraph_DG_QG","random/subgraph_QG_640","random/subgraph_QG_1280","random/subgraph_QG_2560","random/subgraph_QG_5120"]
    43                                             #n_G = [ 80,160,320,640,1280,2560,5120]
    44                                             #foldernames=["random/subgraph_DG_5120"]
    45                                             #foldernames1=["random/subgraph_QG_5120"]
    46                                             #n_G = [5120]
    47                                             #foldernames = [ 'highschool']
    48                                             #n_G = [ 327]
    49                                             #foldernames = [  'highschool']
    50                                             #n_G = [ 327]
    51                                             #n_G = [575,5002,11586]
    52                                             #n_GQ = [453,4623,8325]
    53                                             #n_GT = [437,4483,7555]
    54                                         
    55                                             #foldernames = [ 'male','route','sp']
    56                                             #n_G = [575]
    57                                             #n_G=[5003]
    58                                             #foldernames = ['facebook']
    59                                             #9916
    60                                             #9871
    61    385.7 MiB      0.0 MiB           1       iters =1
    62    385.7 MiB      0.0 MiB          12       percs = [(i+1)/10 for i in range(0,9)]
    63    385.7 MiB      0.0 MiB           1       percs=[0.1]
    64                                             #tun=[1,2,3,4,5,6,7]
    65    385.7 MiB      0.0 MiB           1       tuns=["Alpine","Cone","SGWL","Alpine_Dummy","Grampa","Regal","Fugal","mcmc","GradP"]
    66    385.7 MiB      0.0 MiB           1       tun=[1,2,3,4,5,6,8,9,10]
    67    385.8 MiB      0.1 MiB           1       tuns=["Alpine"]
    68    385.8 MiB      0.0 MiB           1       tun=[1]
    69                                             #tuns=["Alpine_Dummy","Grad","mcmc"]
    70                                         
    71                                         
    72                                             #tun = [1,8,10]
    73                                             #nL=["_Noise5","_Noise10","_Noise15","_Noise20","_Noise25"]
    74                                             #tuns=["Alpine"]
    75                                             #tun=[4,8]
    76                                         
    77                                             #tun = [1]
    78                                             #n_G = [4039]
    79                                             #n_GQ = [9872]
    80                                             #n_GT = [9872]
    81                                         
    82                                             #n_G = [1043]
    83                                             #n_GQ = [1000]
    84                                             #n_GT = [1000]
    85                                         
    86                                             #foldernames = ['sp']
    87    385.8 MiB      0.0 MiB           1       foldernames = [ 'dblp']
    88    385.8 MiB      0.0 MiB           1       n_G = [9916]
    89    825.9 MiB      0.0 MiB           2       def printR(name,forb_norm,accuracy,spec_norm,time_diff,isomorphic=False):
    90    825.9 MiB      0.0 MiB           1           print('---- ',name, '----')
    91    825.9 MiB      0.0 MiB           1           print('----> Forb_norm:', forb_norm)
    92    825.9 MiB      0.0 MiB           1           print('----> Accuracy:', accuracy)
    93    825.9 MiB      0.0 MiB           1           print('----> Spec_norm:', spec_norm)
    94    825.9 MiB      0.0 MiB           1           print('----> Time:', time_diff)
    95    825.9 MiB      0.0 MiB           1           print('----> Isomorphic:', isomorphic)
    96    825.9 MiB      0.0 MiB           1           print()     
    97                                         
    98    385.8 MiB      0.0 MiB           1       experimental_folder=f'./{folderall}/res/'
    99    385.8 MiB      0.0 MiB           1       new_id = generate_new_id(get_max_previous_id(experimental_folder))
   100    385.8 MiB      0.0 MiB           1       experimental_folder=f'./{folderall}/res/_{new_id}/'   
   101    385.8 MiB      0.0 MiB           1       DGS=0
   102    385.8 MiB      0.0 MiB           1       DGES=0
   103    385.8 MiB      0.0 MiB           1       QGS=0
   104    385.8 MiB      0.0 MiB           1       QGES=0
   105    385.8 MiB      0.0 MiB           1       PGS=0
   106    385.8 MiB      0.0 MiB           1       PGES=0         
   107    825.9 MiB      0.0 MiB           2       for k in range(0,len(foldernames)):
   108    406.9 MiB     21.1 MiB           1               G = read_real_graph(n = n_G[k], name_ = f'./raw_data/{foldernames[k]}.txt')
   109    406.9 MiB      0.0 MiB           1               print(G)
   110    406.9 MiB      0.0 MiB           1               DGS=G.number_of_nodes()
   111                                         
   112                                             # Get the number of edges
   113    406.9 MiB      0.0 MiB           1               DGES = G.number_of_edges()
   114                                                     
   115                                                     #perc=percs[0]
   116    825.9 MiB      0.0 MiB           2               for perc in percs: 
   117    825.9 MiB      0.0 MiB           2                   for ptun in range(len(tun)): 
   118    406.9 MiB      0.0 MiB           1                       folder = f'./{folderall}/{foldernames[k]}/{int(perc*100)}'
   119    406.9 MiB      0.0 MiB           1                       os.makedirs(f'{experimental_folder}{foldernames[k]}/{int(perc*100)}', exist_ok=True)
   120    406.9 MiB      0.0 MiB           1                       folder1=f'./{experimental_folder}/{foldernames[k]}/{int(perc*100)}'
   121    406.9 MiB      0.0 MiB           1                       file_A_results = open(f'{folder1}/SizeTest_results{tuns[ptun]}.txt', 'w')
   122    406.9 MiB      0.0 MiB           1                       file_A_results.write(f'DGS DGES QGS QGES PGS PGES forb_norm accuracy spec_norm time isomorphic \n')
   123                                                             
   124    406.9 MiB      0.0 MiB           1                       file_real_spectrum = open(f'{folder1}/real_Tspectrum{tuns[ptun]}.txt', 'w')
   125    406.9 MiB      0.0 MiB           1                       file_A_spectrum = open(f'{folder1}/A_Tspectrum{tuns[ptun]}.txt', 'w')
   126    406.9 MiB      0.0 MiB           1                       n_Q = int(perc*G.number_of_nodes())
   127                                                             #n_Q=n_GQ[k]#9872
   128    406.9 MiB      0.0 MiB           1                       n_Q = 9872 
   129    406.9 MiB      0.0 MiB           1                       print(f'Size of subgraph: {n_Q}')
   130    825.9 MiB      0.0 MiB           2                       for iter in range(iters):
   131    406.9 MiB      0.0 MiB           1                           folder_ = f'{folder}/{iter}'
   132    406.9 MiB      0.0 MiB           1                           folder1_ = f'{folder1}/{iter}'
   133                                                                 #folder_ = f'{folder}'
   134    406.9 MiB      0.0 MiB           1                           os.makedirs(f'{folder1_}', exist_ok=True)
   135    406.9 MiB      0.0 MiB           1                           file_subgraph = f'{folder_}/subgraph.txt'
   136    406.9 MiB      0.0 MiB           1                           file_nodes = f'{folder_}/nodes.txt'
   137                                                                 #file_subgraph = f'raw_data/random/subgraph_QG_{n_G[k]}.txt'
   138                                                                 #file_nodes = f'raw_data/random/nodes_QG_{n_G[k]}.txt'
   139    406.9 MiB      0.0 MiB           1                           Q_real = read_list(file_nodes)
   140    406.9 MiB      0.0 MiB           1                           print(f'Reading subgraph at {file_subgraph}')
   141    406.9 MiB      0.0 MiB           1                           print(f'Reading alignment at {file_nodes}')
   142    425.5 MiB     18.7 MiB           1                           G_Q= read_real_graph(n = n_Q, name_ = file_subgraph)
   143    577.4 MiB    151.9 MiB           1                           A = nx.adjacency_matrix(G_Q).todense()
   144    577.4 MiB      0.0 MiB           1                           print(G_Q)
   145                                                                 #print(Q_real)
   146    577.4 MiB      0.0 MiB           1                           QGS=G_Q.number_of_nodes()
   147    577.4 MiB      0.0 MiB           1                           QGES = G_Q.number_of_edges()
   148                                                                 #L = np.diag(np.array(np.sum(A, axis = 0)))
   149                                                                 #eigv_G_Q, _ = linalg.eig(L - A)
   150                                                                 #idx = eigv_G_Q.argsort()[::]   
   151                                                                 #eigv_G_Q = eigv_G_Q[idx]
   152                                                                 #for el in eigv_G_Q: file_real_spectrum.write(f'{el} ')
   153                                                                 #file_real_spectrum.write(f'\n')
   154    577.4 MiB      0.0 MiB           1                           start = time.time()
   155    577.4 MiB      0.0 MiB           1                           if(tun[ptun]==1):
   156    577.4 MiB      0.0 MiB           1                               print("Alpine")
   157    714.1 MiB    136.7 MiB           1                               _, list_of_nodes, forb_norm = Alpine(G_Q.copy(), G.copy(),mu=1,weight=2)
   158                                                                 elif(tun[ptun]==2):
   159                                                                     print("Cone")
   160                                                                     _, list_of_nodes, forb_norm = coneGAM(G_Q.copy(), G.copy())
   161                                                                 elif(tun[ptun]==3):
   162                                                                     print("SGWL")
   163                                                                     _, list_of_nodes, forb_norm = SGWLSA(G_Q.copy(), G.copy())
   164                                                                 elif(tun[ptun]==4):
   165                                                                     print("Alpine_Dummy")
   166                                                                     _, list_of_nodes, forb_norm = align_new(G_Q.copy(), G.copy(),mu=1,weight=1)
   167                                                                 elif(tun[ptun]==5):
   168                                                                     print("Grampa")
   169                                                                     _, list_of_nodes, forb_norm = Grampa(G_Q.copy(), G.copy())
   170                                                                 elif(tun[ptun]==6):
   171                                                                     print("Regal")
   172                                                                     _, list_of_nodes, forb_norm = Regal(G_Q.copy(), G.copy())      
   173                                                                 elif(tun[ptun]==7):
   174                                                                     print("MDS")
   175                                                                     _, list_of_nodes, forb_norm = MDSGA(G_Q.copy(), G.copy())
   176                                                                 elif(tun[ptun]==8):
   177                                                                     print("fugal")
   178                                                                     _,list_of_nodes, forb_norm = Fugal(G_Q.copy(), G.copy())
   179                                                                 elif(tun[ptun]==9):
   180                                                                     print("mcmc")
   181                                                                     list_of_nodes, forb_norm = mcAlign(G_Q.copy(), G.copy(),Q_real)
   182                                                                 elif(tun[ptun]==10):
   183                                                                     print("GradAlignP")
   184                                                                     list_of_nodes, forb_norm = gradPMain(G_Q.copy(), G.copy())
   185                                                                 else:
   186                                                                     print("NO given algorithm ID")
   187                                                                     exit()
   188    714.1 MiB      0.0 MiB           1                           end = time.time()
   189    714.1 MiB      0.0 MiB           1                           subgraph = G.subgraph(list_of_nodes)
   190                                                                 
   191    714.1 MiB      0.0 MiB           1                           PGS=subgraph.number_of_nodes()
   192    714.1 MiB      0.0 MiB           1                           PGES = subgraph.number_of_edges()
   193    714.1 MiB      0.0 MiB           1                           isomorphic=False
   194    714.1 MiB      0.0 MiB           1                           if(forb_norm==0):
   195                                                                     isomorphic=True
   196    714.1 MiB      0.0 MiB           1                           time_diff = end - start
   197    714.1 MiB      0.0 MiB           1                           file_nodes_pred = open(f'{folder1_}/{tuns[ptun]}.txt','w')
   198    714.1 MiB      0.0 MiB        9873                           for node in list_of_nodes: file_nodes_pred.write(f'{node}\n')
   199    787.4 MiB     73.4 MiB           1                           A = nx.adjacency_matrix(nx.induced_subgraph(G, list_of_nodes)).todense()
   200    825.9 MiB     38.5 MiB           1                           L = np.diag(np.array(np.sum(A, axis = 0)))
   201                                         
   202                                         
   203                                                                 #   accuracy = np.sum(np.array(Q_real)==np.array(list_of_nodes))/len(Q_real)
   204    825.9 MiB      0.0 MiB           1                           accuracy = np.sum(np.array(Q_real)==np.array(list_of_nodes))/1265
   205                                                                 #len(Q_real)
   206    825.9 MiB      0.0 MiB           1                           spec_norm=0
   207    825.9 MiB      0.0 MiB           1                           file_A_results.write(f'{DGS} {DGES} {QGS} {QGES} {PGS} {PGES} {forb_norm} {accuracy} {spec_norm} {time_diff} {isomorphic}\n')
   208    825.9 MiB      0.0 MiB           1                           printR(tuns[ptun],forb_norm,accuracy,0,time_diff,isomorphic)            
   209    825.9 MiB      0.0 MiB           1                   print('\n')
   210    825.9 MiB      0.0 MiB           1               print('\n\n')


